// ‚úÖ server/controllers/upload/uploadProductController.js ‚Äî Prisma singleton, safer errors, cover handling

const { prisma, Prisma } = require('../../lib/prisma');
const { v4: uuidv4 } = require('uuid');
const streamifier = require('streamifier');
const { cloudinary } = require('../../utils/cloudinary');

// Helpers
const toInt = (v) => (v === undefined || v === null || v === '' ? undefined : Number(v));

const uploadAndSaveProductImages = async (req, res) => {
  const productId = toInt(req.params.id);
  const file = req.file;

  const captionsArray = Array.isArray(req.body?.captions)
    ? req.body.captions
    : typeof req.body?.captions === 'string'
    ? [req.body.captions]
    : [];

  const coverIndex = toInt(req.body?.coverIndex);

  console.log('üõ†Ô∏è [UPLOAD] ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡∏†‡∏≤‡∏û Product');
  console.log('üì• productId:', productId);
  console.log('üì• file:', file?.originalname);
  console.log('üì• captionsArray:', captionsArray);
  console.log('üì• coverIndex:', coverIndex);

  try {
    if (!file || !productId) {
      return res.status(400).json({ message: '‡πÑ‡∏°‡πà‡∏û‡∏ö productId ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏ü‡∏•‡πå‡∏†‡∏≤‡∏û‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á' });
    }

    // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á (‡∏Å‡∏±‡∏ô productId ‡∏´‡∏•‡∏∏‡∏î)
    const product = await prisma.product.findUnique({ where: { id: productId }, select: { id: true } });
    if (!product) return res.status(404).json({ message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤' });

    const uniqueName = uuidv4();
    const folder = 'products';
    const publicId = `${folder}/${uniqueName}`;

    const uploadResult = await new Promise((resolve, reject) => {
      const stream = cloudinary.uploader.upload_stream(
        {
          public_id: publicId,
          folder,
          resource_type: 'image',
        },
        (error, result) => {
          if (error) {
            console.error('‚ùå Cloudinary upload error:', error);
            return reject(error);
          }
          console.log('‚úÖ Cloudinary upload result:', result);
          resolve(result);
        }
      );
      streamifier.createReadStream(file.buffer).pipe(stream);
    });

    // ‚úÖ ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ cover ‡πÉ‡∏´‡πâ‡∏°‡∏µ‡πÑ‡∏î‡πâ‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏£‡∏π‡∏õ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏ï‡πà‡∏≠ product (‡∏≠‡∏∞‡∏ï‡∏≠‡∏°‡∏°‡∏¥‡∏Å)
    const newImage = await prisma.$transaction(async (tx) => {
      if (coverIndex === 0) {
        await tx.productImage.updateMany({ where: { productId }, data: { isCover: false } });
      }
      const created = await tx.productImage.create({
        data: {
          productId,
          url: uploadResult.secure_url,
          public_id: uploadResult.public_id,
          secure_url: uploadResult.secure_url,
          caption: captionsArray[0] || '',
          isCover: coverIndex === 0,
        },
      });
      return created;
    });

    console.log('üßæ ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô DB ‡πÅ‡∏•‡πâ‡∏ß:', newImage);

    return res.json({
      message: '‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÅ‡∏•‡∏∞‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏†‡∏≤‡∏û‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
      images: [newImage],
    });
  } catch (err) {
    console.error('‚ùå uploadAndSaveProductImages error:', err);
    return res.status(500).json({ message: 'Upload and Save failed' });
  }
};

const uploadProductImagesOnly = async (req, res) => {
  const files = req.files;

  const captionsArray = Array.isArray(req.body?.captions)
    ? req.body.captions
    : typeof req.body?.captions === 'string'
    ? [req.body.captions]
    : [];

  const coverIndex = toInt(req.body?.coverIndex);

  console.log('üõ†Ô∏è [UPLOAD ONLY] ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡∏†‡∏≤‡∏û Product (temp)');
  console.log('üì• ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÑ‡∏ü‡∏•‡πå:', files?.length);
  console.log('üì• captionsArray:', captionsArray);
  console.log('üì• coverIndex:', coverIndex);

  try {
    if (!files || files.length === 0) {
      return res.status(400).json({ message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î' });
    }

    const uploads = await Promise.all(
      files.map(async (file, index) => {
        const uniqueName = uuidv4();
        const folder = 'products';
        const publicId = `${folder}/${uniqueName}`;

        console.log(`üì§ ‡πÄ‡∏£‡∏¥‡πà‡∏° upload: ${file.originalname} ‚Üí ${publicId}`);

        return new Promise((resolve, reject) => {
          const stream = cloudinary.uploader.upload_stream(
            {
              public_id: publicId,
              folder,
              resource_type: 'image',
            },
            (error, result) => {
              if (error) {
                console.error('‚ùå Cloudinary upload error:', error);
                return reject(error);
              }
              console.log('‚úÖ Cloudinary upload result:', result);
              resolve({
                url: result.secure_url,
                public_id: result.public_id,
                secure_url: result.secure_url,
                caption: captionsArray[index] || '',
                isCover: index === coverIndex,
              });
            }
          );
          streamifier.createReadStream(file.buffer).pipe(stream);
        });
      })
    );

    console.log('üßæ ‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡∏†‡∏≤‡∏û‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');

    return res.json({
      message: '‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡∏†‡∏≤‡∏û‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
      images: uploads,
    });
  } catch (err) {
    console.error('‚ùå uploadProductImagesOnly error:', err);
    return res.status(500).json({ message: 'Upload failed' });
  }
};

const deleteProductImage = async (req, res) => {
  const productId = toInt(req.params.id);
  const { public_id } = req.body || {};

  console.log('üóëÔ∏è [DELETE] ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏•‡∏ö‡∏†‡∏≤‡∏û:', public_id);

  try {
    if (!public_id || !productId) {
      return res.status(400).json({ message: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô' });
    }

    await cloudinary.uploader.destroy(public_id);

    await prisma.productImage.deleteMany({
      where: { productId, public_id },
    });

    console.log('‚úÖ ‡∏•‡∏ö‡∏†‡∏≤‡∏û‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡∏à‡∏≤‡∏Å Cloudinary ‡πÅ‡∏•‡∏∞‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•');
    return res.json({ message: '‡∏•‡∏ö‡∏†‡∏≤‡∏û‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à' });
  } catch (err) {
    console.error('‚ùå deleteProductImage error:', err);
    return res.status(500).json({ message: '‡∏•‡∏ö‡∏†‡∏≤‡∏û‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à' });
  }
};

module.exports = {
  uploadProductImagesOnly,
  uploadAndSaveProductImages,
  deleteProductImage,
};
