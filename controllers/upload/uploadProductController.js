// ‚úÖ server/controllers/upload/uploadProductController.js
const { v4: uuidv4 } = require('uuid');
const streamifier = require('streamifier');
const { cloudinary } = require('../../utils/cloudinary');
const prisma = require('../../lib/prisma');

const uploadAndSaveProductImages = async (req, res) => {
  const productId = parseInt(req.params.id);
  const files = req.files;

  const captionsArray = Array.isArray(req.body.captions)
    ? req.body.captions
    : typeof req.body.captions === 'string'
      ? [req.body.captions]
      : [];

  const coverIndex = parseInt(req.body.coverIndex);

  console.log('üõ†Ô∏è [UPLOAD] ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡∏†‡∏≤‡∏û Product');
  console.log('üì• productId:', productId);
  console.log('üì• ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÑ‡∏ü‡∏•‡πå:', files?.length);
  console.log('üì• captionsArray:', captionsArray);
  console.log('üì• coverIndex:', coverIndex);

  try {
    if (!files || files.length === 0 || isNaN(productId)) {
      return res.status(400).json({ error: '‡πÑ‡∏°‡πà‡∏û‡∏ö productId ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏ü‡∏•‡πå‡∏†‡∏≤‡∏û‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á' });
    }

    const uploads = await Promise.all(
      files.map(async (file, index) => {
        const uniqueName = uuidv4();
        const folder = 'products';
        const publicId = `${folder}/${uniqueName}`;

        console.log(`üì§ ‡πÄ‡∏£‡∏¥‡πà‡∏° upload: ${file.originalname} ‚Üí ${publicId}`);

        return new Promise((resolve, reject) => {
          const stream = cloudinary.uploader.upload_stream(
            {
              public_id: publicId,
              folder,
              resource_type: 'image',
            },
            (error, result) => {
              if (error) {
                console.error('‚ùå Cloudinary upload error:', error);
                return reject(error);
              }
              console.log('‚úÖ Cloudinary upload result:', result);
              resolve({
                url: result.secure_url,
                public_id: result.public_id,
                secure_url: result.secure_url,
              });
            }
          );
          streamifier.createReadStream(file.buffer).pipe(stream);
        });
      })
    );

    const created = await prisma.productImage.createMany({
      data: uploads.map((img, index) => ({
        productId,
        url: img.url,
        public_id: img.public_id,
        secure_url: img.secure_url,
        caption: captionsArray[index] || '',
        isCover: index === coverIndex,
      })),
      skipDuplicates: true,
    });

    console.log('üßæ ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô DB ‡πÅ‡∏•‡πâ‡∏ß:', created);

    res.json({ message: '‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÅ‡∏•‡∏∞‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏†‡∏≤‡∏û‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à', count: created.count });
  } catch (err) {
    console.error('‚ùå uploadAndSaveProductImages error:', err);
    res.status(500).json({ error: 'Upload and Save failed' });
  }
};

const uploadProductImagesOnly = async (req, res) => {
  const files = req.files;

  const captionsArray = Array.isArray(req.body.captions)
    ? req.body.captions
    : typeof req.body.captions === 'string'
      ? [req.body.captions]
      : [];

  const coverIndex = parseInt(req.body.coverIndex);

  console.log('üõ†Ô∏è [UPLOAD ONLY] ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡∏†‡∏≤‡∏û Product (temp)');
  console.log('üì• ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÑ‡∏ü‡∏•‡πå:', files?.length);
  console.log('üì• captionsArray:', captionsArray);
  console.log('üì• coverIndex:', coverIndex);

  try {
    if (!files || files.length === 0) {
      return res.status(400).json({ error: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î' });
    }

    const uploads = await Promise.all(
      files.map(async (file, index) => {
        const uniqueName = uuidv4();
        const folder = 'products';
        const publicId = `${folder}/${uniqueName}`;

        console.log(`üì§ ‡πÄ‡∏£‡∏¥‡πà‡∏° upload: ${file.originalname} ‚Üí ${publicId}`);

        return new Promise((resolve, reject) => {
          const stream = cloudinary.uploader.upload_stream(
            {
              public_id: publicId,
              folder,
              resource_type: 'image',
            },
            (error, result) => {
              if (error) {
                console.error('‚ùå Cloudinary upload error:', error);
                return reject(error);
              }
              console.log('‚úÖ Cloudinary upload result:', result);
              resolve({
                url: result.secure_url,
                public_id: result.public_id,
                secure_url: result.secure_url,
                caption: captionsArray[index] || '',
                isCover: index === coverIndex,
              });
            }
          );
          streamifier.createReadStream(file.buffer).pipe(stream);
        });
      })
    );

    console.log('üßæ ‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡∏†‡∏≤‡∏û‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');

    res.json({
      message: '‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡∏†‡∏≤‡∏û‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
      images: uploads,
    });
  } catch (err) {
    console.error('‚ùå uploadProductImagesOnly error:', err);
    res.status(500).json({ error: 'Upload failed' });
  }
};

module.exports = {
  uploadProductImagesOnly,
  uploadAndSaveProductImages,
};
